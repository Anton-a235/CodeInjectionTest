# CodeInjectionTest
Тестирование метода внедрения исполняемого кода в адресное пространство процессов ОС Windows

**Программа разработана исключительно в исследовательских и демонстрационных целях!**

Решение включает в себя два проекта:
1. RemoteShellDll - динамическая библиотека, реализующая функционал удаленного шелла.
2. AgentInstaller - программа-загрузчик указанной выше DLL в адресное пространство другого процесса.

В данной реализации рассматривается технология внедрения исполняемого кода как метод инсталляции удаленного шелла (в виде DLL) в адресное пространство другого процесса, а также способы управления удаленным компьютером с его применением. Метод изначально тестировался на Windows 7, но также проверена его работоспособность и на Windows 10. Реализована работа только с 32-битными процессами (как в 32-битных, так и в 64-битных версиях Windows).

## Метод внедрения кода
Методы внедрения кода можно разделить на две основных группы: с использованием DLL-библиотеки и без неё. Использование DLL-библиотеки существенно облегчает разработку собственно кода, который будет выполняться удаленно, но является демаскирующим признаком при проведении атаки. Внедрение машинного кода непосредственно в адресное пространство будет менее заметным, однако, подготовка такого кода является очень трудоёмкой задачей, так как требует написание базонезависимого кода, который будет работать правильно, находясь по априори неизвестному адресу в памяти, а также при неизвестных адресах загрузки системных DLL-библиотек. Особенно этот вопрос остро стоит в ОС Windows 7 и выше с реализованной технологией ASLR.

В данной реализации используются оба метода. Код удалённого агента реализован в DLL-библиотеке, а сама DLL внедряется в адресное пространство процесса путём внедрения базонезависимого машинного кода, который загружает DLL посредством вызовов API.

Базонезависимый код, который будет выполнять функции по загрузке DLL, должен отвечать следующим требованиям:
-	в коде не должно быть абсолютных фиксированных адресов;
-	все вызовы функций осуществляются по указателям, которые настраиваются непосредственно перед внедрением;
-	все данные, используемые кодом, хранятся в динамически выделяемой области памяти в структуре, которая загружается параллельно с кодом.

В приведенной реализации применён метод изменения контекста главного потока целевого процесса вместо наиболее распространенного способа – создания удаленного потока. Такой приём позволил (на момент разработки и тестирования) избежать срабатывания модулей проактивной защиты антивирусных программ. Вторым препятствием в реализации внедрения кода был DEP (Data Execution Prevention). Этот механизм ОС, появившийся в Windows Vista и Windows 7, препятствовал исполнению кода, размещаемого в динамически выделенных областях. Здесь эта проблема решена тем, что код вызывается инструкцией RETN, а перед этим адрес возврата записывается в вершину стека. В качестве адреса возврата используется адрес внедренного кода. Такой подход позволяет обойти ограничение DEP на исполнение в произвольных областях.

В результате выполнения внедренного кода подготовленная DLL-библиотека с программным агентом будет загружена в адресное пространство удаленного процесса, а управление вернётся остановленному потоку в том месте, где он был остановлен.

## Демонстрация
Для демонстрации процесса внедрения разработана консольную программа AgentInstaller, которая поддерживает функцию внедрения DLL в другие процессы рассматриваемым методом. В качестве процесса-цели выбран Internet Explorer (iexplore.exe). IE и AgentInstaller запущены на одной виртуальной машине.

Для внедрения библиотеки необходимо запустить программу и ввести ID процесса, в контекст которого нужно её загрузить.

![image](https://user-images.githubusercontent.com/88583217/204553287-cbc0b012-b4d3-4fb5-9b73-0821a6cbf979.png)

В списке модулей процесса можно увидеть загруженную библиотеку с именем 1.tmp.

![image](https://user-images.githubusercontent.com/88583217/204553572-86cf6f09-8089-4cdb-af9a-63c707c1188a.png)

На этом этап внедрения программного агента завершен.

В загруженной DLL функционирует TCP-сервер, который начинает слушать порт 12321 в отдельно созданном потоке. Поток создаётся в момент загрузки DLL в функции DllMain(). Простейший TCP-клиент реализован в виде скрипта на языке Python3. Клиент отправляет вводимую команду серверу и получает ответ после её обработки. На удаленном компьютере все команды выполняются от имени процесса Internet Explorer.

```
import socket

sock = socket.socket()
ip = input('Remote IP: ')
sock.connect((ip, 12321))

while 1:
    s = input('>>>')
    sock.send(bytearray(s, 'cp1251'))
    s = sock.recv(10240)
    print(s.decode('cp1251'))

sock.close()
```

Перехват вывода cmd реализован с помощью перенаправления консольного вывода в файл. После выполнения команды агент читает файл с выводом и отправляет содержимое клиенту. В случае, если вывод отсутствует, агент отравляет код возврата, с которым завершился cmd.

### Пример. Создание нового пользователя на удаленном компьютере.

![image](https://user-images.githubusercontent.com/88583217/204555150-55156442-e828-42f2-bb25-4a110df1ecbe.png)

В панели управления удаленного компьютера появился новый пользователь.

![image](https://user-images.githubusercontent.com/88583217/204555366-7d2ddb82-a777-422d-9a44-d5eca3308ada.png)

Можно добавить этого пользователя в группу Администраторы.

![image](https://user-images.githubusercontent.com/88583217/204555672-5f981d17-10b7-4978-b253-8fd27498870c.png)

![image](https://user-images.githubusercontent.com/88583217/204555831-90df37a9-71a7-41b7-89be-8c9a2fe3d334.png)

### Пример. Вызов калькулятора

![image](https://user-images.githubusercontent.com/88583217/204556437-45d998d6-6fd5-48e1-803f-9d17c26106e1.png)

![image](https://user-images.githubusercontent.com/88583217/204556598-13d965b0-3fb6-4ebd-8080-43a7526038b6.png)

На рисунке в дереве процессов видно, что Internet Explorer является родителем calc.

![image](https://user-images.githubusercontent.com/88583217/204556703-7ceb2dbe-b99b-4ad1-adcb-b31c654a5141.png)

## Удаленный вызов функций API-библиотек
Эта процедура имеет более сложную реализацию. Для удалённого вызова API в консоли клиента нужно ввести команду определенного формата:
```
*Lib_Name!Funct_Name(INT:-123,FLOAT:45.678,LPSTR:"string, with symbols?")
```
- Команда начинается с символа ’*’.
- Lib_Name – имя файла библиотеки (полное или относительное), из которой будет вызываться функция.
- Funct_Name – экспортируемое имя функции в библиотеке.
- Имя библиотеки и имя функции разделяются символом ’!’.
- После имени функции следует список параметров в круглых скобках (может быть пустым).
- Каждый параметр представлен парой «ТИП:ЗНАЧЕНИЕ», разделенной символом ’:’.
- Строковые константы задаются в двойных кавычках.
- Параметры отделены друг от друга запятой.
- Использование пробела в команде не допускается, за исключением строковых констант в кавычках.

При получении команды такого вида сервер должен проверить корректность её формы, прежде чем начать выполнять. Для этой проверки был реализован конечный автомат, модель которого представлена в виде таблицы переходов.

![image](https://user-images.githubusercontent.com/88583217/204557935-54f660b3-60b3-4a14-9c68-992cc65def06.png)

- q – состояние автомата;
- c – символы алфавита.
- q=1 – начальное состояние;
- q=0 – терминальное состояние (команда допустима);
- q=-1 – недопустимый переход (команда не отвечает требованиям).

Работа данной функции продемонстрирована в Windows 10 на видео ниже.

## Тестирование в Windows 10

Сам метод внедрения кода остается работоспособным без изменений в Windows 10 22H2. Лишь некоторые функции для демонстрации метода, такие как перехват вывода cmd после исполнения команды, требуют небольшой доработки. Тем не менее, это не помешало протестировать метод при текущей реализации.

https://user-images.githubusercontent.com/88583217/204562303-65425a3d-8dff-4d74-aad2-c7246a7ee757.mp4
